diff -Naur pciutils-3.1.7-linux/lib/mint-pcibios.c pciutils-3.1.7-mint/lib/mint-pcibios.c
--- pciutils-3.1.7-linux/lib/mint-pcibios.c	1970-01-01 01:00:00.000000000 +0100
+++ pciutils-3.1.7-mint/lib/mint-pcibios.c	2010-11-16 21:26:44.000000000 +0100
@@ -0,0 +1,483 @@
+/*
+ *	The PCI Library -- MiNT PCIBIOS access
+ *
+ *	Adapted from obsd-device.c by Patrice Mandin <patmandin@gmail.com>, 2010
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <mint/cookie.h>
+#include <mint/osbind.h>
+#include <stdio.h>
+
+#include "internal.h"
+
+/*--- Defines ---*/
+
+#define PCIBIOS_BEGIN(stack) \
+	stack=NULL; \
+	if (Super(1)==0) { \
+		stack=(void *)Super(NULL); \
+	}
+
+#define PCIBIOS_END(stack) \
+	if (stack!=NULL) { \
+		Super(stack); \
+	}
+
+#define PCIBIOS_CLOBBER_LIST	\
+  "d1", "d2", "a0", "a1", "a2", "memory"
+
+/*--- PCI bios function calls ---*/
+
+#define PCIBIOSCALL_l_d0ld1w(func_ptr,p1,p2)	\
+__extension__	\
+({	\
+  register long retvalue __asm__("d0");	\
+  \
+  __asm__ volatile (	\
+    "clrl	d1\n\t"	\
+    "movw	%3,d1\n\t"	\
+    "movl	%2,d0\n\t"	\
+    "jbsr	%1@"	\
+    : "=r"(retvalue)	\
+    : "a"(func_ptr), "g"(p1), "g"(p2)	\
+    : PCIBIOS_CLOBBER_LIST	\
+  );	\
+  retvalue;	\
+})
+
+#define PCIBIOSCALL_l_d0la0ld1b(func_ptr,p1,p2,p3)	\
+__extension__	\
+({	\
+  register long retvalue __asm__("d0");	\
+  \
+  __asm__ volatile (	\
+    "clrl	d1\n\t"	\
+    "movb	%4,d1\n\t"	\
+    "movl	%3,a0\n\t"	\
+    "movl	%2,d0\n\t"	\
+    "jbsr	%1@"	\
+    : "=r"(retvalue)	\
+    : "a"(func_ptr), "g"(p1), "g"(p2), "d"(p3)	\
+    : PCIBIOS_CLOBBER_LIST	\
+  );	\
+  retvalue;	\
+})
+
+#define PCIBIOSCALL_l_d0ld1bd2(func_ptr,p1,p2,p3)	\
+__extension__	\
+({	\
+  register long retvalue __asm__("d0");	\
+  \
+  __asm__ volatile (	\
+    "clrl	d1\n\t"	\
+    "movl	%4,d2\n\t"	\
+    "movb	%3,d1\n\t"	\
+    "movl	%2,d0\n\t"	\
+    "jbsr	%1@"	\
+    : "=r"(retvalue)	\
+    : "a"(func_ptr), "g"(p1), "d"(p2), "g"(p3)	\
+    : PCIBIOS_CLOBBER_LIST	\
+  );	\
+  retvalue;	\
+})
+
+/*--- Types ---*/
+
+typedef void (*pci_routine_t)(void);
+
+typedef struct {
+  unsigned long *subcookie;
+  unsigned long version;
+  pci_routine_t pci_routines[43];
+} pci_cookie_t;
+
+/*--- _PCI cookie ---*/
+
+static pci_cookie_t *cookie_pci = NULL;
+static unsigned long cookie_ct60 = 0;
+
+/*--- PCI functions ---*/
+
+static long pcibios_find_device(unsigned long device_handle, unsigned short index)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0ld1w(cookie_pci->pci_routines[0], device_handle, index);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static long pcibios_read_config_byte(unsigned long device_handle, void *data, unsigned char num_register)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0la0ld1b(cookie_pci->pci_routines[2], device_handle, data, num_register);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static long pcibios_read_config_word(unsigned long device_handle, void *data, unsigned char num_register)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0la0ld1b(cookie_pci->pci_routines[3], device_handle, data, num_register);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static long pcibios_read_config_long(unsigned long device_handle, void *data, unsigned char num_register)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0la0ld1b(cookie_pci->pci_routines[4], device_handle, data, num_register);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static long pcibios_write_config_byte(unsigned long device_handle, unsigned char num_register, unsigned char value)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0ld1bd2(cookie_pci->pci_routines[8], device_handle, num_register, value);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static long pcibios_write_config_word(unsigned long device_handle, unsigned char num_register, unsigned short value)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0ld1bd2(cookie_pci->pci_routines[9], device_handle, num_register, value);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static long pcibios_write_config_long(unsigned long device_handle, unsigned char num_register, unsigned long value)
+{
+	long result;
+	void *oldstack;
+
+	PCIBIOS_BEGIN(oldstack);
+	result = PCIBIOSCALL_l_d0ld1bd2(cookie_pci->pci_routines[10], device_handle, num_register, value);
+	PCIBIOS_END(oldstack);
+	return result;
+}
+
+static unsigned long pcibios_read_bar_size(unsigned long device_handle, int config_register)
+{
+	unsigned long old_register, size;
+	int num_bits;
+	
+	/* Read current register value */
+	pcibios_read_config_long(device_handle, &old_register, config_register);
+
+	/* Write not(0) */
+	pcibios_write_config_long(device_handle, config_register, 0xffffffffUL);
+
+	/* Read value */
+	pcibios_read_config_long(device_handle, &size, config_register);
+
+	/* Write previous register value */
+	pcibios_write_config_long(device_handle, config_register, old_register);
+
+	if (!size || size== 0xffffffff) {
+		return 0;
+	}
+
+	/* Find first 0 bit */
+	num_bits = 31;
+	for (num_bits=31; num_bits>0; --num_bits) {
+		if ((size & (1<<num_bits))==0) {
+			break;
+		}
+	}
+
+	return 1<<(num_bits+1);
+}
+
+/*--- Functions ---*/
+
+static int
+mint_detect(struct pci_access *a)
+{
+	/*printf("mint_detect: begin\n");*/
+  if (Getcookie(C__PCI, (unsigned long *) &cookie_pci) != C_FOUND) {
+	/*printf("mint_detect: no _PCI cookie\n");*/
+    return 0;
+  }
+
+  if (Getcookie(C_CT60, (unsigned long *) &cookie_ct60) != C_FOUND) {
+	/*printf("mint_detect: no CT60 cookie\n");*/
+    cookie_ct60 = 0;
+    /* Only supports CTPCI for now */
+    return 0;
+  }
+
+	/*printf("mint_detect: end\n");*/
+  return 1;
+}
+
+static void
+mint_init(struct pci_access *a)
+{
+	/*printf("mint_init\n");*/
+}
+
+static void
+mint_cleanup(struct pci_access *a)
+{
+	/*printf("mint_cleanup\n");*/
+}
+
+static void
+mint_scan_get_resources(struct pci_dev *d, long device_handle)
+{
+  int num_bars = 0, i, config_reg_rom = 0;
+  unsigned long v32;
+
+  switch(d->hdrtype) {
+    case PCI_HEADER_TYPE_NORMAL:
+      num_bars = 6;
+      config_reg_rom = 0x30;
+      break;
+    case PCI_HEADER_TYPE_BRIDGE:
+      num_bars = 2;
+      config_reg_rom = 0x38;
+      break;
+    case PCI_HEADER_TYPE_CARDBUS:
+      num_bars = 1;
+      break;
+  }
+
+  for (i=0; i<num_bars; i++) {
+    int config_reg = 0x10+(i<<2);
+
+    if (pcibios_read_config_long(device_handle, &v32, config_reg) == 0) {
+      d->base_addr[i] = v32;
+      d->size[i] = pcibios_read_bar_size(device_handle, config_reg);
+    }
+  }
+
+  if (config_reg_rom != 0) {
+    if (pcibios_read_config_long(device_handle, &v32, config_reg_rom) == 0) {
+      d->rom_base_addr = v32;
+      d->rom_size = pcibios_read_bar_size(device_handle, config_reg_rom);
+    }
+  }
+
+  d->known_fields |= PCI_FILL_BASES | PCI_FILL_ROM_BASE | PCI_FILL_SIZES;
+}
+
+static void
+mint_scan(struct pci_access *a)
+{
+  int num_device = -1, ht, multi;
+  long result, device_handle;
+  struct pci_dev *d;
+  u32 vd;
+
+	/*printf("mint_scan: begin\n");
+	printf("mint_scan: cookie_pci: 0x%08x\n", cookie_pci);
+	printf("mint_scan: cookie_pci: 0x%08x\n", cookie_pci);
+	printf("mint_scan:  version 0x%08x\n", cookie_pci->version);*/
+  for (;;) {
+    num_device++;
+
+    result = pcibios_find_device(0x0000ffffL, num_device);
+    if (result<0) {
+      break;
+    }
+    device_handle = result;
+
+	/*printf("mint_scan: add device 0x%08x\n", device_handle);*/
+    d = pci_alloc_dev(a);
+
+    d->bus = 0;
+    d->dev = device_handle & 0xffff;	/* CTPCI stores func|dev in device_handle, do not know about Milan/Hades */
+    d->func = device_handle >> 16U;
+
+    vd = pci_read_long(d, PCI_VENDOR_ID);
+    d->vendor_id = vd & 0xffff;
+    d->device_id = vd >> 16U;
+    d->known_fields = PCI_FILL_IDENT;
+
+    ht = pci_read_byte(d, PCI_HEADER_TYPE);
+    multi = 0;
+    if (!d->func)
+      multi = ht & 0x80;
+    ht &= 0x7f;
+
+    d->hdrtype = ht;
+
+    mint_scan_get_resources(d, device_handle);
+
+    pci_link_dev(a, d);
+    switch (ht)
+    {
+      case PCI_HEADER_TYPE_NORMAL:
+        break;
+      case PCI_HEADER_TYPE_BRIDGE:
+      case PCI_HEADER_TYPE_CARDBUS:
+        /*pci_generic_scan_bus(a, busmap, pci_read_byte(t, PCI_SECONDARY_BUS));*/
+        break;
+      default:
+        a->debug("Device %04x:%02x:%02x.%d has unknown header type %02x.\n", d->domain, d->bus, d->dev, d->func, ht);
+    }
+  }
+
+	/*printf("mint_scan: end\n");*/
+}
+
+static int
+mint_read(struct pci_dev *d, int pos, byte *buf, int len)
+{
+	long result, device_handle;
+	int i;
+
+	if (pos >= 256)
+		return 0;
+
+	device_handle = d->dev | ((d->func)<<16);
+
+	/*printf("mint_read: device 0x%08x pos %d len %d\n", device_handle, pos, len);*/
+
+	i = 0;
+	while (i<len) {
+		/* Multiple of 4 ? */
+		if (((pos & 3)==0) && (len>=4)) {
+			unsigned long v32;
+
+			result = pcibios_read_config_long(device_handle, &v32, pos);
+			if (result != 0) {
+				return 0;
+			}
+			((unsigned long *)buf)[0] = swab32(v32);
+			buf += 4;
+			pos += 4;
+			i += 4;
+			continue;
+		}
+
+		/* Multiple of 2 ? */
+		if (((pos & 1)==0) && (len>=2)) {
+			unsigned short v16;
+
+			result = pcibios_read_config_word(device_handle, &v16, pos);
+			if (result != 0) {
+				return 0;
+			}
+			((unsigned short *)buf)[0] = swab16(v16);
+			buf += 2;
+			pos += 2;
+			i += 2;
+			continue;
+		}
+
+		/* Bytes */
+		result = pcibios_read_config_byte(device_handle, buf, pos);
+		if (result != 0) {
+			return 0;
+		}
+		buf++;
+		pos++;
+		i++;
+	}
+
+	return 1;
+}
+
+static int
+mint_write(struct pci_dev *d, int pos, byte *buf, int len)
+{
+	long result, device_handle;
+	int i;
+
+	if (pos >= 256)
+		return 0;
+
+	device_handle = d->dev | ((d->func)<<16);
+
+	/*printf("mint_write: device 0x%08x pos %d len %d\n", device_handle, pos, len);*/
+
+	i = 0;
+	while (i<len) {
+		/* Multiple of 4 ? */
+		if (((pos & 3)==0) && (len>=4)) {
+			unsigned long v32;
+
+			v32 = swab32(((unsigned long *)buf)[0]);
+
+			result = pcibios_write_config_long(device_handle, pos, v32);
+			if (result != 0) {
+				return 0;
+			}
+			buf += 4;
+			pos += 4;
+			i += 4;
+			continue;
+		}
+
+		/* Multiple of 2 ? */
+		if (((pos & 1)==0) && (len>=2)) {
+			unsigned short v16;
+
+			v16 = swab16(((unsigned short *)buf)[0]);
+
+			result = pcibios_write_config_word(device_handle, pos, v16);
+			if (result != 0) {
+				return 0;
+			}
+			buf += 2;
+			pos += 2;
+			i += 2;
+			continue;
+		}
+
+		/* Bytes */
+		result = pcibios_write_config_byte(device_handle, pos, *buf);
+		if (result != 0) {
+			return 0;
+		}
+		buf++;
+		pos++;
+		i++;
+	}
+
+	return 1;
+}
+
+struct pci_methods pm_mint_pcibios = {
+  "mint-pcibios",
+  "PciBios on MiNT",
+  NULL,
+  mint_detect,
+  mint_init,
+  mint_cleanup,
+  mint_scan,
+  pci_generic_fill_info,
+  mint_read,
+  mint_write,
+  NULL,                                 /* read_vpd */
+  NULL,                                 /* dev_init */
+  NULL                                  /* dev_cleanup */
+};
